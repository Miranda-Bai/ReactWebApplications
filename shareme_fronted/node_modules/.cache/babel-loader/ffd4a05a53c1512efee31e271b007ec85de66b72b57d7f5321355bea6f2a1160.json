{"ast":null,"code":"// src/util/browser-shouldRetry.js\nvar browser_shouldRetry_default = (err, attempt, options) => {\n  if (options.method !== \"GET\" && options.method !== \"HEAD\") {\n    return false;\n  }\n  return err.isNetworkError || false;\n};\n\n// src/middleware/retry.js\nvar isStream = stream => stream !== null && typeof stream === \"object\" && typeof stream.pipe === \"function\";\nvar retry = function () {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const maxRetries = opts.maxRetries || 5;\n  const retryDelay = opts.retryDelay || getRetryDelay;\n  const allowRetry = opts.shouldRetry || browser_shouldRetry_default;\n  return {\n    onError: (err, context) => {\n      const options = context.options;\n      const max = options.maxRetries || maxRetries;\n      const shouldRetry = options.shouldRetry || allowRetry;\n      const attemptNumber = options.attemptNumber || 0;\n      if (isStream(options.body)) {\n        return err;\n      }\n      if (!shouldRetry(err, attemptNumber, options) || attemptNumber >= max) {\n        return err;\n      }\n      const newContext = Object.assign({}, context, {\n        options: Object.assign({}, options, {\n          attemptNumber: attemptNumber + 1\n        })\n      });\n      setTimeout(() => context.channels.request.publish(newContext), retryDelay(attemptNumber));\n      return null;\n    }\n  };\n};\nretry.shouldRetry = browser_shouldRetry_default;\nvar retry_default = retry;\nfunction getRetryDelay(attemptNum) {\n  return 100 * Math.pow(2, attemptNum) + Math.random() * 100;\n}\nexport { retry_default };","map":{"version":3,"mappings":";AAAA,IAAOA,8BAAQ,CAACC,KAAKC,SAASC,YAAY;EACxC,IAAIA,QAAQC,WAAW,SAASD,QAAQC,WAAW,QAAQ;IACzD,OAAO;EACT;EAEA,OAAOH,IAAII,kBAAkB;AAC/B;;;ACJA,IAAMC,WAAWC,UACfA,WAAW,QAAQ,OAAOA,WAAW,YAAY,OAAOA,OAAOC,SAAS;AAE1E,IAAMC,QAAQ,YAAe;EAAA,IAAdC,2EAAO,CAAC;EACrB,MAAMC,aAAaD,KAAKC,cAAc;EACtC,MAAMC,aAAaF,KAAKE,cAAcC;EACtC,MAAMC,aAAaJ,KAAKK,eAAef;EAEvC,OAAO;IACLgB,SAAS,CAACf,KAAKgB,YAAY;MACzB,MAAMd,UAAUc,QAAQd;MACxB,MAAMe,MAAMf,QAAQQ,cAAcA;MAClC,MAAMI,cAAcZ,QAAQY,eAAeD;MAC3C,MAAMK,gBAAgBhB,QAAQgB,iBAAiB;MAG/C,IAAIb,SAASH,QAAQiB,IAAI,GAAG;QAC1B,OAAOnB;MACT;MAGA,IAAI,CAACc,YAAYd,KAAKkB,eAAehB,OAAO,KAAKgB,iBAAiBD,KAAK;QACrE,OAAOjB;MACT;MAGA,MAAMoB,aAAaC,OAAOC,OAAO,CAAC,GAAGN,SAAS;QAC5Cd,SAASmB,OAAOC,OAAO,CAAC,GAAGpB,SAAS;UAACgB,eAAeA,gBAAgB;QAAC,CAAC;MACxE,CAAC;MAGDK,WAAW,MAAMP,QAAQQ,SAASC,QAAQC,QAAQN,UAAU,GAAGT,WAAWO,aAAa,CAAC;MAGxF,OAAO;IACT;EACF;AACF;AAEAV,MAAMM,cAAcf;AAEpB,IAAO4B,gBAAQnB;AAEf,SAASI,cAAcgB,YAAY;EACjC,OAAO,MAAMC,KAAKC,IAAI,GAAGF,UAAU,IAAIC,KAAKE,QAAO,GAAI;AACzD","names":["browser_shouldRetry_default","err","attempt","options","method","isNetworkError","isStream","stream","pipe","retry","opts","maxRetries","retryDelay","getRetryDelay","allowRetry","shouldRetry","onError","context","max","attemptNumber","body","newContext","Object","assign","setTimeout","channels","request","publish","retry_default","attemptNum","Math","pow","random"],"sources":["/Users/Shared/Files From f.localized/GitHub/ReactWebApplications/SHAREME/shareme_fronted/node_modules/get-it/src/util/browser-shouldRetry.js","/Users/Shared/Files From f.localized/GitHub/ReactWebApplications/SHAREME/shareme_fronted/node_modules/get-it/src/middleware/retry.js"],"sourcesContent":["export default (err, attempt, options) => {\n  if (options.method !== 'GET' && options.method !== 'HEAD') {\n    return false\n  }\n\n  return err.isNetworkError || false\n}\n","import defaultShouldRetry from '../util/node-shouldRetry'\n\nconst isStream = stream =>\n  stream !== null && typeof stream === 'object' && typeof stream.pipe === 'function'\n\nconst retry = (opts = {}) => {\n  const maxRetries = opts.maxRetries || 5\n  const retryDelay = opts.retryDelay || getRetryDelay\n  const allowRetry = opts.shouldRetry || defaultShouldRetry\n\n  return {\n    onError: (err, context) => {\n      const options = context.options\n      const max = options.maxRetries || maxRetries\n      const shouldRetry = options.shouldRetry || allowRetry\n      const attemptNumber = options.attemptNumber || 0\n\n      // We can't retry if body is a stream, since it'll be drained\n      if (isStream(options.body)) {\n        return err\n      }\n\n      // Give up?\n      if (!shouldRetry(err, attemptNumber, options) || attemptNumber >= max) {\n        return err\n      }\n\n      // Create a new context with an increased attempt number, so we can exit if we reach a limit\n      const newContext = Object.assign({}, context, {\n        options: Object.assign({}, options, {attemptNumber: attemptNumber + 1})\n      })\n\n      // Wait a given amount of time before doing the request again\n      setTimeout(() => context.channels.request.publish(newContext), retryDelay(attemptNumber))\n\n      // Signal that we've handled the error and that it should not propagate further\n      return null\n    }\n  }\n}\n\nretry.shouldRetry = defaultShouldRetry\n\nexport default retry\n\nfunction getRetryDelay(attemptNum) {\n  return 100 * Math.pow(2, attemptNum) + Math.random() * 100\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}