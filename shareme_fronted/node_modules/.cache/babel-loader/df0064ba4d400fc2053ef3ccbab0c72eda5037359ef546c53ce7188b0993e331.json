{"ast":null,"code":"import { __esm, __export, __toCommonJS } from \"./chunk-U7HSCTZN.mjs\";\n\n// src/middleware/cancel/Cancel.js\nvar Cancel_exports = {};\n__export(Cancel_exports, {\n  default: () => Cancel_default\n});\nfunction Cancel(message) {\n  this.message = message;\n}\nvar Cancel_default;\nvar init_Cancel = __esm({\n  \"src/middleware/cancel/Cancel.js\"() {\n    Cancel.prototype.toString = function toString() {\n      return `Cancel${this.message ? `: ${this.message}` : \"\"}`;\n    };\n    Cancel.prototype.__CANCEL__ = true;\n    Cancel_default = Cancel;\n  }\n});\n\n// src/middleware/promise.js\ninit_Cancel();\n\n// src/middleware/cancel/CancelToken.js\nvar Cancel2 = (init_Cancel(), __toCommonJS(Cancel_exports));\nfunction CancelToken(executor) {\n  if (typeof executor !== \"function\") {\n    throw new TypeError(\"executor must be a function.\");\n  }\n  let resolvePromise = null;\n  this.promise = new Promise(resolve => {\n    resolvePromise = resolve;\n  });\n  executor(message => {\n    if (this.reason) {\n      return;\n    }\n    this.reason = new Cancel2(message);\n    resolvePromise(this.reason);\n  });\n}\nCancelToken.source = function () {\n  let cancel;\n  const token = new CancelToken(can => {\n    cancel = can;\n  });\n  return {\n    token,\n    cancel\n  };\n};\nvar CancelToken_default = CancelToken;\n\n// src/middleware/cancel/isCancel.js\nvar isCancel_default = value => !!(value && value.__CANCEL__);\n\n// src/middleware/promise.js\nvar globalPromise = typeof Promise === \"function\" && Promise;\nvar promise = function () {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const Promise2 = options.implementation || globalPromise;\n  if (!Promise2) {\n    throw new Error(\"`Promise` is not available in global scope, and no implementation was passed\");\n  }\n  return {\n    onReturn: (channels, context) => new Promise2((resolve, reject) => {\n      const cancel = context.options.cancelToken;\n      if (cancel) {\n        cancel.promise.then(reason => {\n          channels.abort.publish(reason);\n          reject(reason);\n        });\n      }\n      channels.error.subscribe(reject);\n      channels.response.subscribe(response => {\n        resolve(options.onlyBody ? response.body : response);\n      });\n      setTimeout(() => {\n        try {\n          channels.request.publish(context);\n        } catch (err) {\n          reject(err);\n        }\n      }, 0);\n    })\n  };\n};\npromise.Cancel = Cancel_default;\npromise.CancelToken = CancelToken_default;\npromise.isCancel = isCancel_default;\nvar promise_default = promise;\nexport { promise_default };","map":{"version":3,"mappings":";;;AAAA;AAAAA;EAAAC;AAAA;AAAA,SAASC,OAAOC,SAAS;EACvB,KAAKA,UAAUA;AACjB;AAFA,IAUOC;AAVP;EAAA;IAIAF,OAAOG,UAAUC,WAAW,SAASA,WAAW;MAC9C,OAAO,SAAS,KAAKH,UAAU,KAAK,KAAKA,YAAY;IACvD;IAEAD,OAAOG,UAAUE,aAAa;IAEvBH,iBAAQF;EAAA;AAAA;;;ACVfM;;;ACAA,IAAMN,WAASM;AAEf,SAASC,YAAYC,UAAU;EAC7B,IAAI,OAAOA,aAAa,YAAY;IAClC,MAAM,IAAIC,UAAU,8BAA8B;EACpD;EAEA,IAAIC,iBAAiB;EACrB,KAAKC,UAAU,IAAIC,QAAQC,WAAW;IACpCH,iBAAiBG;EACnB,CAAC;EAEDL,SAASP,WAAW;IAClB,IAAI,KAAKa,QAAQ;MAEf;IACF;IAEA,KAAKA,SAAS,IAAId,QAAOC,OAAO;IAChCS,eAAe,KAAKI,MAAM;EAC5B,CAAC;AACH;AAEAP,YAAYQ,SAAS,YAAW;EAC9B,IAAIC;EACJ,MAAMC,QAAQ,IAAIV,YAAYW,OAAO;IACnCF,SAASE;EACX,CAAC;EAED,OAAO;IACLD;IACAD;EACF;AACF;AAEA,IAAOG,sBAAQZ;;;ACnCf,IAAOa,mBAAQC,SAAS,CAAC,EAAEA,SAASA,MAAMhB;;;AFI1C,IAAMiB,gBAAgB,OAAOV,YAAY,cAAcA;AAEvD,IAAMD,UAAU,YAAkB;EAAA,IAAjBY,8EAAU,CAAC;EAC1B,MAAMX,WAAUW,QAAQC,kBAAkBF;EAC1C,IAAI,CAACV,UAAS;IACZ,MAAM,IAAIa,MAAM,8EAA8E;EAChG;EAEA,OAAO;IACLC,UAAU,CAACC,UAAUC,YACnB,IAAIhB,SAAQ,CAACC,SAASgB,WAAW;MAC/B,MAAMb,SAASY,QAAQL,QAAQO;MAC/B,IAAId,QAAQ;QACVA,OAAOL,QAAQoB,KAAKjB,UAAU;UAC5Ba,SAASK,MAAMC,QAAQnB,MAAM;UAC7Be,OAAOf,MAAM;QACf,CAAC;MACH;MAEAa,SAASO,MAAMC,UAAUN,MAAM;MAC/BF,SAASS,SAASD,UAAUC,YAAY;QACtCvB,QAAQU,QAAQc,WAAWD,SAASE,OAAOF,QAAQ;MACrD,CAAC;MAGDG,WAAW,MAAM;QACf,IAAI;UACFZ,SAASa,QAAQP,QAAQL,OAAO;QAClC,SAASa,KAAP;UACAZ,OAAOY,GAAG;QACZ;MACF,GAAG,CAAC;IACN,CAAC;EACL;AACF;AAEA9B,QAAQX,SAASE;AACjBS,QAAQJ,cAAcY;AACtBR,QAAQ+B,WAAWtB;AAEnB,IAAOuB,kBAAQhC","names":["__export","default","Cancel","message","Cancel_default","prototype","toString","__CANCEL__","init_Cancel","CancelToken","executor","TypeError","resolvePromise","promise","Promise","resolve","reason","source","cancel","token","can","CancelToken_default","isCancel_default","value","globalPromise","options","implementation","Error","onReturn","channels","context","reject","cancelToken","then","abort","publish","error","subscribe","response","onlyBody","body","setTimeout","request","err","isCancel","promise_default"],"sources":["/Users/Shared/Files From f.localized/GitHub/ReactWebApplications/SHAREME/shareme_fronted/node_modules/get-it/src/middleware/cancel/Cancel.js","/Users/Shared/Files From f.localized/GitHub/ReactWebApplications/SHAREME/shareme_fronted/node_modules/get-it/src/middleware/promise.js","/Users/Shared/Files From f.localized/GitHub/ReactWebApplications/SHAREME/shareme_fronted/node_modules/get-it/src/middleware/cancel/CancelToken.js","/Users/Shared/Files From f.localized/GitHub/ReactWebApplications/SHAREME/shareme_fronted/node_modules/get-it/src/middleware/cancel/isCancel.js"],"sourcesContent":["function Cancel(message) {\n  this.message = message\n}\n\nCancel.prototype.toString = function toString() {\n  return `Cancel${this.message ? `: ${this.message}` : ''}`\n}\n\nCancel.prototype.__CANCEL__ = true\n\nexport default Cancel\n","import Cancel from './cancel/Cancel'\nimport CancelToken from './cancel/CancelToken'\nimport isCancel from './cancel/isCancel'\n\nconst globalPromise = typeof Promise === 'function' && Promise\n\nconst promise = (options = {}) => {\n  const Promise = options.implementation || globalPromise\n  if (!Promise) {\n    throw new Error('`Promise` is not available in global scope, and no implementation was passed')\n  }\n\n  return {\n    onReturn: (channels, context) =>\n      new Promise((resolve, reject) => {\n        const cancel = context.options.cancelToken\n        if (cancel) {\n          cancel.promise.then(reason => {\n            channels.abort.publish(reason)\n            reject(reason)\n          })\n        }\n\n        channels.error.subscribe(reject)\n        channels.response.subscribe(response => {\n          resolve(options.onlyBody ? response.body : response)\n        })\n\n        // Wait until next tick in case cancel has been performed\n        setTimeout(() => {\n          try {\n            channels.request.publish(context)\n          } catch (err) {\n            reject(err)\n          }\n        }, 0)\n      })\n  }\n}\n\npromise.Cancel = Cancel\npromise.CancelToken = CancelToken\npromise.isCancel = isCancel\n\nexport default promise\n","const Cancel = require('./Cancel')\n\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.')\n  }\n\n  let resolvePromise = null\n  this.promise = new Promise(resolve => {\n    resolvePromise = resolve\n  })\n\n  executor(message => {\n    if (this.reason) {\n      // Cancellation has already been requested\n      return\n    }\n\n    this.reason = new Cancel(message)\n    resolvePromise(this.reason)\n  })\n}\n\nCancelToken.source = function() {\n  let cancel\n  const token = new CancelToken(can => {\n    cancel = can\n  })\n\n  return {\n    token: token,\n    cancel: cancel\n  }\n}\n\nexport default CancelToken\n","export default value => !!(value && value.__CANCEL__)\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}